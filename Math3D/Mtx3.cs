using System;

namespace Math3D
{
    public struct Mtx3 : IEquatable<Mtx3>
    {
        #region Public Fields

        public static Mtx3 Identity = new Mtx3(1, 0, 0, 0, 1, 0, 0, 0, 1);

        public Vec3 Row0;

        //------------------------------------------------------------------------------------------------------------------------------------------------------
        public Vec3 Row1;

        public Vec3 Row2;

        #endregion Public Fields

        #region Public Constructors

        //------------------------------------------------------------------------------------------------------------------------------------------------------
        //------------------------------------------------------------------------------------------------------------------------------------------------------
        public Mtx3(
            double m00, double m01, double m02,
            double m10, double m11, double m12,
            double m20, double m21, double m22)
        {
            Row0 = new Vec3(m00, m01, m02);
            Row1 = new Vec3(m10, m11, m12);
            Row2 = new Vec3(m20, m21, m22);
        }

        //------------------------------------------------------------------------------------------------------------------------------------------------------
        //------------------------------------------------------------------------------------------------------------------------------------------------------
        public Mtx3(Vec3 row0, Vec3 row1, Vec3 row2)
        {
            Row0 = row0;
            Row1 = row1;
            Row2 = row2;
        }

        #endregion Public Constructors

        #region Public Properties

        //------------------------------------------------------------------------------------------------------------------------------------------------------
        public Vec3 Column0
        {
            get { return new Vec3(Row0.X, Row1.X, Row2.X); }
        }

        //------------------------------------------------------------------------------------------------------------------------------------------------------
        //------------------------------------------------------------------------------------------------------------------------------------------------------
        //------------------------------------------------------------------------------------------------------------------------------------------------------
        public Vec3 Column1
        {
            get { return new Vec3(Row0.Y, Row1.Y, Row2.Y); }
        }

        //------------------------------------------------------------------------------------------------------------------------------------------------------
        //------------------------------------------------------------------------------------------------------------------------------------------------------
        public Vec3 Column2
        {
            get { return new Vec3(Row0.Z, Row1.Z, Row2.Z); }
        }

        #endregion Public Properties

        #region Public Methods

        //------------------------------------------------------------------------------------------------------------------------------------------------------
        public static Mtx3 Invert(Mtx3 m)
        {
            // Do not touch anuthing!!!
            Mtx3 mi = new Mtx3();
            //
            double d1 = m.Row1.Y * m.Row2.Z - m.Row1.Z * m.Row2.Y;
            double d2 = m.Row1.Z * m.Row2.X - m.Row1.X * m.Row2.Z;
            double d3 = m.Row1.X * m.Row2.Y - m.Row1.Y * m.Row2.X;
            //
            double det = 1 / (m.Row0.X * d1 + m.Row0.Y * d2 + m.Row0.Z * d3);
            if (double.IsInfinity(det))
            {
                throw new Exception("not inversible!");
            }
            //
            mi.Row0.X = d1 * det;
            mi.Row1.X = d2 * det;
            mi.Row2.X = d3 * det;
            //
            mi.Row0.Y = (m.Row2.Y * m.Row0.Z - m.Row2.Z * m.Row0.Y) * det;
            mi.Row1.Y = (m.Row2.Z * m.Row0.X - m.Row2.X * m.Row0.Z) * det;
            mi.Row2.Y = (m.Row2.X * m.Row0.Y - m.Row2.Y * m.Row0.X) * det;
            //
            mi.Row0.Z = (m.Row0.Y * m.Row1.Z - m.Row0.Z * m.Row1.Y) * det;
            mi.Row1.Z = (m.Row0.Z * m.Row1.X - m.Row0.X * m.Row1.Z) * det;
            mi.Row2.Z = (m.Row0.X * m.Row1.Y - m.Row0.Y * m.Row1.X) * det;
            // 
            return mi;
        }


     
            //------------------------------------------------------------------------------------------------------------------------------------------------------
            //------------------------------------------------------------------------------------------------------------------------------------------------------
         
        //------------------------------------------------------------------------------------------------------------------------------------------------------
        public bool Equals(Mtx3 other)
        {
            return
                Row0 == other.Row0 &&
                    Row1 == other.Row1 &&
                    Row2 == other.Row2;
        }

        //------------------------------------------------------------------------------------------------------------------------------------------------------
        //------------------------------------------------------------------------------------------------------------------------------------------------------
        public override bool Equals(object obj)
        {
            if (!(obj is Mtx3))
                return false;

            return this.Equals((Mtx3)obj);
        }

        //------------------------------------------------------------------------------------------------------------------------------------------------------
        //------------------------------------------------------------------------------------------------------------------------------------------------------
        public override int GetHashCode()
        {
            return Row0.GetHashCode() ^ Row1.GetHashCode() ^ Row2.GetHashCode();
        }

        //------------------------------------------------------------------------------------------------------------------------------------------------------
        //------------------------------------------------------------------------------------------------------------------------------------------------------
     

        #endregion Public Methods


        public static Mtx3 operator *(Mtx3 left, Mtx3 right)
        {
            double lM11 = left.Row0.X, lM12 = left.Row0.Y, lM13 = left.Row0.Z,
                lM21 = left.Row1.X, lM22 = left.Row1.Y, lM23 = left.Row1.Z,
                lM31 = left.Row2.X, lM32 = left.Row2.Y, lM33 = left.Row2.Z,
                rM11 = right.Row0.X, rM12 = right.Row0.Y, rM13 = right.Row0.Z,
                rM21 = right.Row1.X, rM22 = right.Row1.Y, rM23 = right.Row1.Z, 
                rM31 = right.Row2.X, rM32 = right.Row2.Y, rM33 = right.Row2.Z;
            Mtx3 result;
            result.Row0.X = (((lM11 * rM11) + (lM12 * rM21)) + (lM13 * rM31)) ;
            result.Row0.Y = (((lM11 * rM12) + (lM12 * rM22)) + (lM13 * rM32)) ;
            result.Row0.Z = (((lM11 * rM13) + (lM12 * rM23)) + (lM13 * rM33)) ;
            result.Row1.X = (((lM21 * rM11) + (lM22 * rM21)) + (lM23 * rM31)) ;
            result.Row1.Y = (((lM21 * rM12) + (lM22 * rM22)) + (lM23 * rM32)) ;
            result.Row1.Z = (((lM21 * rM13) + (lM22 * rM23)) + (lM23 * rM33)) ;
            result.Row2.X = (((lM31 * rM11) + (lM32 * rM21)) + (lM33 * rM31)) ;
            result.Row2.Y = (((lM31 * rM12) + (lM32 * rM22)) + (lM33 * rM32)) ;
            result.Row2.Z = (((lM31 * rM13) + (lM32 * rM23)) + (lM33 * rM33)) ;
            return result;
        }
        //------------------------------------------------------------------------------------------------------------------------------------------------------
    }
}